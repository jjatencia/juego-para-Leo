<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Explota-Color — Juego infantil tipo Toon Blast</title>
<style>
  :root {
    --bg: #0f172a; /* slate-900 */
    /* --tile-size now computed inside .board for responsiveness */
    --gap: 10px;
    --radius: 18px;

    /* Colores de fichas (altas, cálidas y alegres) */
    --c1: #ff4d4f; /* rojo */
    --c2: #3b82f6; /* azul */
    --c3: #22c55e; /* verde */
    --c4: #f59e0b; /* amarillo */
    --c5: #a855f7; /* morado */

    --text: #e5e7eb; /* gray-200 */
    --muted: #9ca3af; /* gray-400 */
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: radial-gradient(1200px 800px at 20% -10%, #1f2937, transparent),
                radial-gradient(1200px 800px at 120% 10%, #111827, transparent),
                var(--bg);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 16px;
    padding: 16px;
  }

  header {
    display: grid; grid-template-columns: 1fr auto auto; align-items: center; gap: 12px;
    background: linear-gradient(180deg, #0b1021, #0a0f1e);
    border: 1px solid #1f2937; border-radius: 16px; padding: 12px;
    box-shadow: 0 10px 25px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.02);
  }
  .title { font-weight: 800; letter-spacing: .3px; display:flex; align-items:center; gap:10px; }
  .title .logo { font-size: 28px; filter: drop-shadow(0 4px 6px rgba(0,0,0,.4)); }
  .title span { font-size: 18px; }

  .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items:center; }
  .controls select { padding: 9px 10px; border-radius: 12px; border: 1px solid #334155; background:#0b1021; color:#e5e7eb; font-weight:700; }
  button, .toggle {
    border: 0; border-radius: 14px; padding: 10px 14px; font-weight: 700;
    color: white; background: #374151; cursor: pointer; transition: transform .06s ease, filter .2s;
  }
  button:hover { filter: brightness(1.1); }
  button:active { transform: translateY(1px) scale(0.98); }
  .primary { background: linear-gradient(180deg, #ec4899, #db2777); }
  .warn { background: linear-gradient(180deg, #f59e0b, #d97706); }

  .stats { display:flex; gap: 12px; align-items:center; font-weight:700; justify-self: end; }
  .pill { background:#111827; border:1px solid #1f2937; padding:8px 12px; border-radius:999px; color:#e5e7eb; }

  .board-wrap { position: relative; display: grid; place-items: center; width: 100%; height: 100%; }
  .board {
    --rows: 8;
    /* Responsive tile: fits iPhone screens (width and height), with a soft max */
    --tile-size: min(
      calc((100vw - 40px - (var(--gap) * (var(--cols) - 1))) / var(--cols)),
      calc((100vh - 260px - (var(--gap) * (var(--rows) - 1))) / var(--rows)),
      88px
    );
    display: grid;
    grid-template-columns: repeat(var(--cols), var(--tile-size));
    grid-auto-rows: var(--tile-size);
    gap: var(--gap);
    padding: 12px;
    border-radius: 24px;
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border: 1px solid #1f2937;
    box-shadow: 0 20px 50px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
    user-select: none;
    touch-action: manipulation;
  }

  .tile {
    position: relative; display: grid; place-items: center; font-size: calc(var(--tile-size) * .45);
    font-weight: 900; color: #111827; border-radius: var(--radius);
    box-shadow: 0 8px 0 rgba(0,0,0,.25), 0 14px 24px rgba(0,0,0,.25);
    transform: translateZ(0);
    transition: transform .08s ease, filter .15s ease;
    outline: 3px solid rgba(255,255,255,.08);
  }
  .tile:active { transform: translateY(2px) scale(.97); }
  .tile::after { /* brillo */
    content: ""; position: absolute; inset: 0; border-radius: var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.05) 28%, transparent 55%);
    pointer-events: none;
  }
  .c1 { background: var(--c1); }
  .c2 { background: var(--c2); }
  .c3 { background: var(--c3); }
  .c4 { background: var(--c4); }
  .c5 { background: var(--c5); }

  /* Especiales */
  .special { color: #fff; font-size: calc(var(--tile-size) * .42); }
  .ball {
    position: relative;
    /* Neon glow: fuerte y llamativo */
    --glow: #fff; /* se ajusta por color */
    box-shadow:
      0 0 0 3px rgba(255,255,255,.25),
      0 0 22px var(--glow),
      0 0 70px var(--glow),
      0 10px 0 rgba(0,0,0,.25),
      0 18px 28px rgba(0,0,0,.3);
    animation: neonPulse 1.2s ease-in-out infinite;
  }
  /* brillo de color según la clase */
  .ball.c1 { --glow: var(--c1); }
  .ball.c2 { --glow: var(--c2); }
  .ball.c3 { --glow: var(--c3); }
  .ball.c4 { --glow: var(--c4); }
  .ball.c5 { --glow: var(--c5); }
  .ball::before {
    content: ""; position: absolute; inset: -6px; border-radius: inherit; pointer-events: none;
    background: radial-gradient(circle at 50% 45%, var(--glow), rgba(255,255,255,.7) 35%, rgba(255,255,255,0) 60%);
    filter: blur(6px); opacity: .95; animation: throb 1.1s infinite ease-in-out;
  }
  .ball::after {
    content: ""; position: absolute; inset: -14px; border-radius: inherit; pointer-events: none;
    background: conic-gradient(from 0deg, transparent 0 35%, var(--glow) 35% 55%, transparent 55% 100%);
    mix-blend-mode: screen; opacity: .7; animation: spin 2.8s linear infinite;
    mask: radial-gradient(farthest-side, transparent 58%, #000 60%);
  }
  @keyframes neonPulse { 0%,100%{ transform: scale(1); filter: brightness(1); } 50%{ transform: scale(1.06); filter: brightness(1.25); } }
  @keyframes throb { 0%,100%{ opacity:.8 } 50%{ opacity:1 } }
  @keyframes spin { to { transform: rotate(360deg); } }
  .pulse { animation: pulse 1.2s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.08)} }

  /* Efectos */
  .glowpop { animation: glowpop .28s ease-out forwards; }
  @keyframes glowpop {
    0%   { transform: scale(1); opacity: 1; box-shadow: 0 0 0 0 var(--glow, transparent); }
    70%  { transform: scale(1.25); box-shadow: 0 0 18px 10px var(--glow, rgba(255,255,255,.5)); }
    100% { transform: scale(0.6); opacity: 0; box-shadow: 0 0 0 0 transparent; }
  }
  .shockwave { position: fixed; width: 12px; height: 12px; border-radius: 999px; left:0; top:0;
    transform: translate(-50%,-50%) scale(0); pointer-events:none; z-index: 9997;
    background: radial-gradient(circle, var(--wave, #fff) 0 35%, rgba(255,255,255,.0) 36% 100%);
    mix-blend-mode: screen; animation: shock 800ms ease-out forwards; }
  @keyframes shock { to { transform: translate(-50%,-50%) scale(40); opacity: 0; } }
  .screen-flash { position: fixed; inset: 0; pointer-events:none; z-index: 9996; opacity: 0;
    background: radial-gradient(closest-side, var(--flash, #fff), rgba(255,255,255,0) 70%);
    animation: flash .35s ease-out forwards; }
  @keyframes flash { 0%{opacity:0} 35%{opacity:.55} 100%{opacity:0} }

  /* Piezas/fragmentos al romper */
  .piece { position: fixed; width: 8px; height: 8px; border-radius: 2px; opacity: .95;
    left: 0; top: 0; transform: translate(-50%,-50%); pointer-events: none; z-index: 9997;
    animation: piece 800ms ease-out forwards; }
  @keyframes piece { to { transform: translate(calc(-50% + var(--dx,0px)), calc(-50% + var(--dy,0px))) rotate(360deg); opacity: 0; } }

  /* Caída bonita */
  .fall { animation: drop var(--dur, 220ms) cubic-bezier(.2,.8,.2,1) both; }
  @keyframes drop { from { transform: translateY(-60%); } to { transform: translateY(0); } }

  /* iPhone layout tweaks */
  @media (max-width: 430px) {
    :root { --gap: 6px; }
    body { padding: max(10px, env(safe-area-inset-top)) 10px 10px 10px; }
    header { grid-template-columns: 1fr; gap: 8px; }
    .stats { justify-self: start; }
    .controls { gap: 6px; }
    .board { padding: 8px; border-radius: 18px; }
    .title span { font-size: 16px; }
    button { padding: 10px 12px; }
  }

  .bounce { animation: bounce .35s ease; }
  @keyframes bounce { 0%{transform:translateY(0)} 40%{transform:translateY(-8px)} 100%{transform:translateY(0)} }

  .toast { position: fixed; left: 50%; top: 12px; transform: translateX(-50%);
    background: #111827; border: 1px solid #1f2937; color:#fff; padding:10px 14px; border-radius:999px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35); z-index: 9999; font-weight: 800; letter-spacing: .2px; }

  .celebrate { position: fixed; inset: 0; pointer-events: none; overflow: hidden; z-index: 9998; }
  .confetti { position: absolute; width: 10px; height: 10px; border-radius: 2px; opacity: .9; animation: fall .9s ease-out forwards; }
  @keyframes fall { from { transform: translate(var(--x,0), var(--y,0)) rotate(0deg); opacity: 1; } to { transform: translate(calc(var(--x,0) * 8px), calc(var(--y,0) * 8px)) rotate(360deg); opacity: 0; } }

  /* Modal */
  .modal { position: fixed; inset: 0; background: rgba(0,0,0,.65); display: grid; place-items: center; z-index: 10000; }
  .modal-card{ background:#0b1021; border:1px solid #1f2937; border-radius:16px; padding:24px; text-align:center; box-shadow:0 30px 60px rgba(0,0,0,.5); }
  .modal h2{ margin:0 0 8px 0; }

  footer { text-align:center; color: var(--muted); font-size: 12px; }
  .hint { color: #a7f3d0; font-weight: 700; }
</style>
</head>
<body>
  <header>
    <div class="title"><div class="logo">🧸✨</div><span>Explota‑Color</span></div>
    <div class="controls">
      <label for="levelSel" style="font-weight:700; opacity:.9">Nivel:</label>
      <select id="levelSel" title="Nivel">
        <option value="easy">Fácil</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Difícil</option>
      </select>
      <button class="primary" id="newBtn">Nuevo</button>
      <button id="soundBtn" class="warn">Sonido: ON</button>
      <button id="fsBtn">Pantalla completa</button>
    </div>
    <div class="stats">
      <div class="pill">Obj: <span id="target">0</span></div>
      <div class="pill">Puntos: <span id="score">0</span></div>
      <div class="pill">Movs: <span id="moves">0</span></div>
    </div>
  </header>

  <div class="board-wrap">
    <div id="board" class="board" aria-label="Tablero"></div>
    <div class="celebrate" id="celebrate"></div>
  </div>

  <footer>
    Toques en grupos de <b class="hint">2+</b>. Con <b>5+</b> se crea una <i>pelota</i> del color tocado; al tocarla elimina <b>solo su color</b>. Si <b>juntas 2 pelotas</b>, limpia <b>toda la pantalla</b>.
  </footer>

<script>
(function(){
  const COLS = 6; const ROWS = 8;
  const COLORS = [
    { key: 'c1', emoji: '🍓', ball: '🔴', name:'rojo' },
    { key: 'c2', emoji: '🫐', ball: '🔵', name:'azul' },
    { key: 'c3', emoji: '🥝', ball: '🟢', name:'verde' },
    { key: 'c4', emoji: '🍌', ball: '🟡', name:'amarillo' },
    { key: 'c5', emoji: '🍇', ball: '🟣', name:'morado' }
  ];

  const LEVELS = {
    easy:   { alpha: 0.15, breakMax: 6, target: 3000 }, // clusters frecuentes
    normal: { alpha: 0.60, breakMax: 5, target: 5000 }, // clusters moderados
    hard:   { alpha: 2.00, breakMax: 3, target: 7000 }  // clusters escasos
  };

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const targetEl = document.getElementById('target');
  const newBtn = document.getElementById('newBtn');
  const levelSel = document.getElementById('levelSel');
  const soundBtn = document.getElementById('soundBtn');
  const fsBtn = document.getElementById('fsBtn');
  const confettiLayer = document.getElementById('celebrate');

  let state = { grid: [], score: 0, movesLeft: 30, target: 5000, sound: true, status:'playing', level:'normal' };
  let locked = false; // bloquea entradas mientras hay animaciones/cambios

  function init(){
    state.level = (levelSel.value)||'normal';
    boardEl.style.setProperty('--cols', COLS);
    boardEl.style.setProperty('--rows', ROWS);
    generateBoard();
    state.score = 0; state.movesLeft = 30; state.target = LEVELS[state.level].target; state.status='playing';
    ensureMoves();
    render();
    updateHUD();
  }

  function generateBoard(){
    const { alpha, breakMax } = LEVELS[state.level] || LEVELS.normal;
    // Relleno con sesgo anti-cluster (evita repetir color con izquierda/arriba según alpha)
    state.grid = Array.from({length: ROWS}, ()=>Array.from({length: COLS}, ()=>({kind:'normal', color:0, fall:0})));
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const scores = COLORS.map((_,c)=>{
          let penalty = 0;
          if (x>0 && state.grid[y][x-1]?.color===c) penalty++;
          if (y>0 && state.grid[y-1][x]?.color===c) penalty++;
          // score inverso: más penalización → menos probabilidad
          const weight = 1 / (1 + penalty * alpha);
          return {c, w: weight};
        });
        const chosen = weightedChoice(scores);
        state.grid[y][x].color = chosen;
      }
    }
    // Post-proceso: romper grupos demasiado grandes en función del nivel
    breakLargeGroups(breakMax);
  }

  function weightedChoice(items){
    const total = items.reduce((s,i)=>s+i.w,0);
    let r = Math.random()*total;
    for (const it of items){ if ((r-=it.w)<=0) return it.c; }
    return items[items.length-1].c;
  }

  function breakLargeGroups(maxAllowed){
    let changed = false; let safety=0;
    do {
      changed = false; safety++; if (safety>30) break;
      const visited = new Set();
      for (let y=0;y<ROWS;y++){
        for (let x=0;x<COLS;x++){
          const key = x+','+y; if (visited.has(key)) continue;
          const t = state.grid[y][x]; if (!t || t.kind!=='normal') continue;
          const g = flood(x,y,t.color);
          for (const [gx,gy] of g) visited.add(gx+','+gy);
          if (g.length>maxAllowed){
            changed = true;
            // recolorea aleatoriamente ~30% del grupo
            const slice = Math.max(1, Math.floor(g.length*0.3));
            for (let i=0;i<slice;i++){
              const [rx,ry] = g[Math.floor(Math.random()*g.length)];
              // elegir color diferente a vecinos inmediatos
              const forbid = new Set();
              if (rx>0) forbid.add(state.grid[ry][rx-1]?.color);
              if (ry>0) forbid.add(state.grid[ry-1][rx]?.color);
              if (rx+1<COLS) forbid.add(state.grid[ry][rx+1]?.color);
              if (ry+1<ROWS) forbid.add(state.grid[ry+1][rx]?.color);
              const choices = [0,1,2,3,4].filter(c=>!forbid.has(c));
              if (choices.length){ state.grid[ry][rx].color = choices[Math.floor(Math.random()*choices.length)]; }
              else { state.grid[ry][rx].color = (state.grid[ry][rx].color+1)%5; }
            }
          }
        }
      }
    } while(changed);
  }

  function updateHUD(){
    scoreEl.textContent = state.score;
    movesEl.textContent = state.movesLeft;
    targetEl.textContent = state.target;
  }

  function render(){
    const frag = document.createDocumentFragment();
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const t = state.grid[y][x];
        const div = document.createElement('button');
        div.className = 'tile';
        div.setAttribute('aria-label', `Ficha ${y+1},${x+1}`);
        div.dataset.x = x; div.dataset.y = y;
        if (!t) {
          div.style.visibility = 'hidden';
        } else if (t.kind === 'normal'){
          div.classList.add(['c1','c2','c3','c4','c5'][t.color]);
          div.textContent = COLORS[t.color].emoji;
        } else if (t.kind === 'ball'){
          div.classList.add('special', 'ball', 'pulse', ['c1','c2','c3','c4','c5'][t.color]);
          div.textContent = COLORS[t.color].ball;
        }
        if (t && t.fall>0){
          div.classList.add('fall');
          div.style.setProperty('--dur', (200 + 120 * Math.min(t.fall,4)) + 'ms');
          t.fall = 0;
        }
        frag.appendChild(div);
      }
    }
    boardEl.innerHTML = '';
    boardEl.appendChild(frag);
  }

  // Delegación de eventos para evitar referencias a nodos eliminados
  boardEl.addEventListener('click', (e)=>{
    if (locked || state.status!=='playing') return;
    const el = (e.target && e.target.closest) ? e.target.closest('.tile') : null;
    if (!el || !boardEl.contains(el)) return;
    const x = +el.dataset.x; const y = +el.dataset.y;
    onTileClick(el, x, y);
  });

  function onTileClick(el, x, y){
    const tile = state.grid[y]?.[x];
    if (!tile) return;

    if (tile.kind === 'ball') {
      spendMove();
      if (state.status!=='playing') return;
      const cluster = ballCluster(x,y);
      if (cluster.length >= 2) {
        activateDoubleBalls(cluster);
      } else {
        activateColorBall(x,y,tile.color);
      }
      return;
    }

    // normal
    const group = flood(x,y, tile.color);
    const min = 2; // regla: mínimo 2 iguales
    if (group.length < min){
      try { el.classList.add('bounce'); setTimeout(()=>{ if (el && el.classList) el.classList.remove('bounce'); }, 350); } catch(_){ }
      return;
    }

    spendMove();
    if (state.status!=='playing') return; // por si llegaba a 0 justo aquí

    if (group.length >= 5){
      // Crear pelota de color en (x,y), NO activar
      for (const [gx,gy] of group){ if (!(gx===x && gy===y)) removeWithShards(gx,gy, tile.color); }
      state.grid[y][x] = { kind:'ball', color: tile.color, fall:0 };
      render();
      toast('¡Pelota creada!');
      playTone(720);
      gravity(); fill(); ensureMoves(); render();
      postActionChecks();
      return;
    }

    // Grupo 2-4 normal
    for (const [gx,gy] of group){ removeWithShards(gx,gy, tile.color); }
    addScore(scoreForCount(group.length));
    vibrate(20);
    gravity(); fill(); ensureMoves(); render();
    postActionChecks();
  }

  // ==== Puntuación ====
  function scoreForCount(n){
    if (n < 2) return 0;
    if (n === 2) return 15;
    if (n === 3) return 30;
    if (n === 4) return 50;
    if (n === 5) return 80;
    // para >5, crecimiento lineal generoso (más fácil alcanzar objetivos)
    return 80 + (n - 5) * 50;
  }
  function scoreForColorClear(n){ return n * 45; } // más recompensa: facilitar progreso
  function scoreForFullClear(n){ return n * 35; }   // limpiar pantalla: alto pero controlado
  function addScore(v){ state.score += v; toast('+'+v+' pts'); }

  // ==== Especiales: pelotas de color ====
  function ballCluster(x,y){
    const seen = new Set(); const stack=[[x,y]]; const out=[];
    while (stack.length){
      const [cx,cy] = stack.pop(); const key=cx+','+cy; if (seen.has(key)) continue;
      if (!inBounds(cx,cy)) continue; const t = state.grid[cy][cx]; if (!t || t.kind!=='ball') continue;
      seen.add(key); out.push([cx,cy]); stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
    }
    return out;
  }
  function activateColorBall(x,y,color){
    locked = true;
    // consumir pelota
    state.grid[y][x] = null;

    const colorVars = ['var(--c1)','var(--c2)','var(--c3)','var(--c4)','var(--c5)'];
    const colorVar = colorVars[color];
    screenFlash(colorVar);
    shockwaveFrom(x, y, colorVar);
    bigConfetti(colorVar, 60);

    const targets = [];
    for (let yy=0;yy<ROWS;yy++) for (let xx=0;xx<COLS;xx++){
      const t = state.grid[yy][xx]; if (t && t.kind==='normal' && t.color===color) targets.push([xx,yy]);
    }
    for (const [tx,ty] of targets){ const el = boardEl.querySelector(`[data-x="${tx}"][data-y="${ty}"]`); if (el){ el.style.setProperty('--glow', colorVar); el.classList.add('glowpop'); } }

    setTimeout(()=>{
      for (const [tx,ty] of targets){ removeWithShards(tx,ty,color); }
      addScore(scoreForColorClear(targets.length));
      playTone(360);
      gravity(); fill(); ensureMoves(); render(); locked=false; postActionChecks();
    }, 350);
  }
  function activateDoubleBalls(cluster){
    locked = true;
    // Consumir pelotas del cluster
    for (const [bx,by] of cluster){ state.grid[by][bx] = null; }

    screenFlash('#ffffff');
    if (cluster[0]) shockwaveFrom(cluster[0][0], cluster[0][1], '#ffffff');
    setTimeout(()=>bigConfetti('var(--c1)', 50), 0);
    setTimeout(()=>bigConfetti('var(--c2)', 50), 80);
    setTimeout(()=>bigConfetti('var(--c3)', 50), 160);

    const targets=[];
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){ const t=state.grid[y][x]; if (t && t.kind==='normal') targets.push([x,y,t.color]); }

    for (const [x,y,c] of targets){ const el=boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`); if (el){ el.style.setProperty('--glow', 'rgba(255,255,255,.85)'); el.classList.add('glowpop'); } }

    setTimeout(()=>{
      for (const [x,y,c] of targets){ removeWithShards(x,y,c); }
      addScore(scoreForFullClear(targets.length));
      playTone(420);
      gravity(); fill(); ensureMoves(); render(); locked=false; postActionChecks();
    }, 420);
  }

  function removeWithShards(x,y,colorIndex){
    const t = state.grid[y][x];
    if (!t) return;
    state.grid[y][x] = null;
    spawnPiecesAt(x,y, ['var(--c1)','var(--c2)','var(--c3)','var(--c4)','var(--c5)'][colorIndex]);
  }

  function spawnPiecesAt(x,y,colorVar){
    try{
      const el = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      const br = boardEl.getBoundingClientRect();
      const r = el ? el.getBoundingClientRect() : {left: br.left + br.width/2, top: br.top + br.height/2, width:0, height:0};
      const cx = r.left + r.width/2; const cy = r.top + r.height/2;
      for (let i=0;i<6;i++){
        const p = document.createElement('div'); p.className='piece';
        const dx = (Math.random()*160-80).toFixed(0)+'px';
        const dy = (Math.random()*160-40).toFixed(0)+'px';
        p.style.left = cx+'px'; p.style.top = cy+'px'; p.style.setProperty('--dx', dx); p.style.setProperty('--dy', dy);
        p.style.background = colorVar; confettiLayer.appendChild(p); setTimeout(()=>p.remove(), 900);
      }
    }catch(_){ }
  }

  function shockwaveFrom(x,y,colorVar){
    try{
      const originEl = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      const boardRect = boardEl.getBoundingClientRect();
      const oRect = originEl ? originEl.getBoundingClientRect() : {left: boardRect.left + boardRect.width/2, top: boardRect.top + boardRect.height/2, width:0, height:0};
      const cx = oRect.left + oRect.width/2; const cy = oRect.top + oRect.height/2;
      const sw = document.createElement('div'); sw.className='shockwave'; sw.style.setProperty('--wave', colorVar);
      sw.style.left = cx + 'px'; sw.style.top = cy + 'px';
      document.body.appendChild(sw); setTimeout(()=>sw.remove(), 820);
    }catch(_){ }
  }
  function screenFlash(colorVar){ const f=document.createElement('div'); f.className='screen-flash'; f.style.setProperty('--flash', colorVar); document.body.appendChild(f); setTimeout(()=>f.remove(), 360); }
  function bigConfetti(colorVar, n){ for (let i=0;i<n;i++){ const s=document.createElement('div'); s.className='confetti'; s.style.left=Math.random()*100+'%'; s.style.top='0%'; s.style.setProperty('--x',(Math.random()*2-1).toFixed(2)); s.style.setProperty('--y',(6+Math.random()*10).toFixed(2)); s.style.background=colorVar; confettiLayer.appendChild(s); setTimeout(()=>s.remove(), 1000);} }

  function gravity(){
    for (let x=0;x<COLS;x++){
      let write = ROWS-1;
      for (let y=ROWS-1;y>=0;y--){
        const t = state.grid[y][x];
        if (t){
          state.grid[write][x] = t;
          if (write!==y){ t.fall = Math.max(1, write - y); state.grid[y][x]=null; }
          write--;
        }
      }
      for (let y=write; y>=0; y--) state.grid[y][x] = null;
    }
  }
  function fill(){ for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) if (!state.grid[y][x]) state.grid[y][x] = {kind:'normal', color:Math.floor(Math.random()*5), fall:0}; }

  function ensureMoves(){ if (hasMoves()) return; toast('Mezcla mágica ✨'); const normals=[]; for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){ const t=state.grid[y][x]; if (t && t.kind==='normal') normals.push(t.color);} shuffle(normals); for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){ const t=state.grid[y][x]; if (t && t.kind==='normal') t.color = normals.pop(); } if (!hasMoves()) { const c = Math.floor(Math.random()*5); state.grid[0][0].color=c; state.grid[0][1].color=c; state.grid[0][2].color=c; } }

  function hasMoves(){
    // Busca cualquier grupo de 2+
    const seen = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const t = state.grid[y][x]; if (!t || t.kind!=='normal' || seen[y][x]) continue;
        const group = flood(x,y,t.color);
        for (const [gx,gy] of group) seen[gy][gx]=true;
        if (group.length>=2) return true;
      }
    }
    return false;
  }

  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function flood(x,y,color){
    const seen = new Set();
    const stack = [[x,y]];
    const out = [];
    while (stack.length){
      const [cx,cy] = stack.pop();
      const key = cx+","+cy;
      if (seen.has(key)) continue;
      seen.add(key);
      if (!inBounds(cx,cy)) continue;
      const t = state.grid[cy][cx];
      if (!t || t.kind !== 'normal' || t.color !== color) continue;
      out.push([cx,cy]);
      stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
    }
    return out;
  }

  function inBounds(x,y){ return x>=0 && y>=0 && x<COLS && y<ROWS; }

  function spendMove(){
    if (state.movesLeft<=0) return; // seguridad
    state.movesLeft--; updateHUD();
    // No hacemos gameOver aquí: dejamos que puntúe/caiga todo y luego decidimos en postActionChecks
  }

  function postActionChecks(){
    updateHUD();
    if (state.status!=='playing') return;
    if (state.score >= state.target) { win(); return; }
    if (state.movesLeft === 0) { gameOver(); }
  }

  function gameOver(){ state.status='ended'; showModal('Game Over', 'Inténtalo de nuevo'); vibrate([50,30,50]); }
  function win(){ state.status='ended'; toast('¡Objetivo conseguido!'); for(let i=0;i<8;i++){ bigConfetti(['var(--c1)','var(--c2)','var(--c3)','var(--c4)','var(--c5)'][i%5], 40); } vibrate(60); showModal('¡Victoria!', '¡Bien hecho!'); }

  function showModal(title, subtitle){
    const m = document.createElement('div'); m.className='modal'; m.innerHTML = `
      <div class="modal-card">
        <h2>${title}</h2>
        <p>${subtitle}</p>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:center">
          <button id="againBtn" class="primary">Jugar de nuevo</button>
          <button id="closeBtn">Cerrar</button>
        </div>
      </div>`;
    document.body.appendChild(m);
    m.querySelector('#againBtn').addEventListener('click', ()=>{ m.remove(); init(); });
    m.querySelector('#closeBtn').addEventListener('click', ()=>{ m.remove(); });
  }

  // UI
  newBtn.addEventListener('click', ()=>{ init(); toast('Nuevo tablero'); playTone(700); });
  levelSel.addEventListener('change', ()=>{ init(); toast('Nivel: '+levelSel.options[levelSel.selectedIndex].text+' — Obj '+LEVELS[levelSel.value].target); });
  soundBtn.addEventListener('click', ()=>{ state.sound=!state.sound; soundBtn.textContent = 'Sonido: ' + (state.sound?'ON':'OFF'); toast(state.sound? 'Sonido activado' : 'Sonido desactivado'); });
  fsBtn.addEventListener('click', ()=>{ const el = document.documentElement; if (!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); } });

  // Feedback
  function toast(msg){ const t = document.createElement('div'); t.className='toast'; t.textContent = msg; document.body.appendChild(t); setTimeout(()=>t.remove(), 1400); }

  // Sonidos muy simples
  let audioCtx; function playTone(freq){ if (!state.sound) return; try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='triangle'; o.frequency.value=freq; o.connect(g); g.connect(audioCtx.destination); g.gain.setValueAtTime(0.0001, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.22, audioCtx.currentTime+0.01); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.18); o.start(); o.stop(audioCtx.currentTime+0.2); } catch(e){} }
  function vibrate(pat){ if (navigator.vibrate) { try{ navigator.vibrate(pat); }catch(_){}} }

  // ===============
  // Auto‑tests (no intrusivos): ayudan a detectar regresiones
  // ===============
  function runTests(){
    const saveGrid = JSON.parse(JSON.stringify(state.grid));
    const saveScore = state.score; const saveMoves = state.movesLeft; const saveStatus = state.status; const saveLevel = state.level;

    // Test 0: puntuación base
    console.assert(scoreForCount(2)===15, 'Score 2 debe ser 15');
    console.assert(scoreForCount(3)===30, 'Score 3 debe ser 30');
    console.assert(scoreForCount(4)===50, 'Score 4 debe ser 50');
    console.assert(scoreForCount(5)===80, 'Score 5 debe ser 80');

    // Test A: ensureMoves deja el tablero con jugadas >=2
    state.level='normal'; generateBoard(); ensureMoves(); console.assert(hasMoves(), 'TestA: jugadas (2+) tras ensureMoves');

    // Test B: grupo de 5 crea pelota del mismo color sin auto-activar
    state.grid = [
      [n(1), n(1), n(1), n(1), n(1), n(2)],
      [n(2), n(3), n(4), n(0), n(0), n(0)],
      ...Array.from({length: ROWS-2}, ()=>Array.from({length: COLS}, ()=>n(2)))
    ];
    state.movesLeft = 10; state.score = 0; state.status='playing';
    const dummy = document.createElement('div'); dummy.className='tile'; dummy.dataset.x='2'; dummy.dataset.y='0';
    onTileClick(dummy,2,0); // hace grupo 5 rojo (1)
    console.assert(state.grid[0][2] && state.grid[0][2].kind==='ball' && state.grid[0][2].color===1, 'TestB: queda pelota roja');

    // Test C: pelota de color limpia su color y puntúa
    state.grid = Array.from({length: ROWS}, ()=>Array.from({length: COLS}, ()=>n(0)));
    state.grid[0][0] = {kind:'ball', color:0, fall:0}; render();
    const beforeC = state.score; activateColorBall(0,0,0);
    setTimeout(()=>{ console.assert(state.score>beforeC, 'TestC: pelota debe puntuar'); }, 450);

    // Test D: doble pelota limpia toda la pantalla y puntúa
    generateBoard();
    state.grid[0][0] = {kind:'ball', color:0, fall:0};
    state.grid[0][1] = {kind:'ball', color:1, fall:0}; render();
    const beforeD = state.score; activateDoubleBalls([[0,0],[1,0]]);
    setTimeout(()=>{ console.assert(state.score>beforeD, 'TestD: doble pelota debe puntuar'); }, 600);

    // Test E: Hard genera menos grupos >=5 que Easy
    state.level='easy'; generateBoard(); const bigEasy = countBigGroups(5);
    state.level='hard'; generateBoard(); const bigHard = countBigGroups(5);
    console.assert(bigHard <= bigEasy, 'TestE: Hard debe tener <= grupos grandes que Easy');

    // Test F: última jugada puntúa y luego termina
    state.level='normal';
    state.grid = [
      [n(1), n(1), n(2), n(3), n(4), n(0)],
      ...Array.from({length: ROWS-1}, ()=>Array.from({length: COLS}, ()=>n(2)))
    ];
    state.movesLeft = 1; state.score = 0; state.status='playing'; render();
    const beforeF = state.score;
    const tap = document.createElement('div'); tap.className='tile'; tap.dataset.x='0'; tap.dataset.y='0';
    onTileClick(tap,0,0);
    setTimeout(()=>{
      console.assert(state.score > beforeF, 'TestF: la última jugada debe sumar');
      console.assert(state.status==='ended', 'TestF: tras la última jugada el juego termina');
    }, 500);

    // Restaurar
    setTimeout(()=>{ state.grid = saveGrid; state.score = saveScore; state.movesLeft = saveMoves; state.status = saveStatus; state.level = saveLevel; render(); updateHUD(); }, 700);
  }
  function n(c){ return {kind:'normal', color:c, fall:0}; }
  function countBigGroups(min){
    const visited = new Set(); let cnt=0;
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){
      const key=x+','+y; if (visited.has(key)) continue; const t=state.grid[y][x]; if(!t||t.kind!=='normal') continue; const g=flood(x,y,t.color); for(const [gx,gy] of g) visited.add(gx+','+gy); if(g.length>=min) cnt++; }
    return cnt;
  }

  // Inicio
  init();
  try { runTests(); } catch(err){ console.warn('Tests fallaron', err); }

})();
</script>
</body>
</html>
